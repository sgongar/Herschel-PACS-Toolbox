# 
#  This file is part of Herschel Common Science System (HCSS).
#  Copyright 2001-2010 Herschel Science Ground Segment Consortium
# 
#  HCSS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as
#  published by the Free Software Foundation, either version 3 of
#  the License, or (at your option) any later version.
# 
#  HCSS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU Lesser General Public License for more details.
# 
#  You should have received a copy of the GNU Lesser General
#  Public License along with HCSS.
#  If not, see <http://www.gnu.org/licenses/>.
# 
"""
VERSION     
  $Id: L1_ChopNod.py,v 1.40 2015/10/15 18:39:45 jdejong Exp $      <do not touch. This field is changed by CVS>

PURPOSE
   PACS Spectrometer Pipeline of chop/nod AORs starting at level 0.5

   This is the second level of the pipeline scripts of the SPG - the Standard Product Generation, 
   a.k.a. the automatic pipeline that the HSC runs - and that which your HSA-gotten ObservationContext  
   were reduced with, if they were reduced in this same track. 

   The SPG scripts are similar to the interactive pipeline (ipipe) scripts that PACS provides in HIPE,  
   but there are extra tasks that the ipipe scripts include, and so users should consider re-reducing
   their data with the ipipe scripts.
   This SPG script is provided so you can see what your HSA-gotten Observation Context levels 
   were reduced with. We provide some comments explaining what the individual tasks do, but for detailed 
   comments see the ipipe scripts, and for a detailed explanation of the pipeline, see the PACS Data 
   Reduction Guide.

   The ipipe scripts can be found under the HIPE menu Pipelines->Spectrometer->. From there you go 
   to the pipeline suited for your observation, such as Chopped line scan and short range scan->lineScan. 


AUTHOR
   Juergen Schreiber <schreiber@mpia.de>

WARNING: 
   Do not edit this file! This is the reference copy for your current 
   installation of HIPE. We recommend you first copy it to a different  
   location before editing.



INPUTS
   - obs : ObservationContext
       - Products needed to run the pipeline are extracted from it
       - Must already be loaded in HIPE, and should contain the previously-reduced Level 0.5
   - camera : camera to reduce (only one done at a time)
       - "red" or "blue"
   - calTree : Calibration Tree from the observation, or generated within your HIPE session 

HISTORY
  2009-03-13 JS 1.0 initial version 
  2009-06-24 JS 1.1 updated
  2009-07-16 JS 1.2 introduce slicing   
  2013-04-04 KME improve comments
"""
from herschel.pacs.spg.pipeline import *
from herschel.pacs.spg.spec import *
from herschel.pacs.spg.common import *
from herschel.pacs.signal.context import *
from herschel.pacs.cal import GetPacsCalDataTask
from herschel.pacs.spg.common import SlicingRule
from herschel.ia.numeric import *
from herschel.pacs.spg.pipeline.spg_spec_tools import *

#*******************************************************************************
# Preparation
#*******************************************************************************

# SETUP 1: 
#    red or blue camera? This the user has to set before running the script, using the command e.g.
#       > camera = "blue" 
#    the try/except here will set the camera to "blue" if it has not already been defined
try:
    camera
except NameError:
    camera = 'blue'

# Extract the (previously-reduced and saved) level 0_5 out of the ObservationContext
level0_5 = PacsContext(obs.level0_5)


#
# SETUP 2:
# Set up the calibration tree. 
# First check whether calTree already exists, since it could have been filled by the SPG pipeline 
# If not, then take it from your current HIPE build, and then put it into the ObservationContext 
#  so that it is stored there for future reference
try:
    calTree
except NameError:
    calTree = getCalTree(obs=obs)
    obs.calibration = calTree
#
#
# extract the frames for your camera
slicedFrames = level0_5.fitted.getCamera(camera).product

# Check that the science frames are not masked out
checkScienceAvailable(slicedFrames)

#
#

#
#***********************************************************************************
#         Processing
# ***********************************************************************************
#
# Detect and flag glitches ("GLITCH" mask)
# copy=True makes slicedFrames a fully independent product
# Activate all masks, for all slices, before deglitching
slicedFrames = activateMasks(slicedFrames, String1d([" "]), exclusive = True, copy = True)
slicedFrames = specFlagGlitchFramesQTest(slicedFrames)
#
#
# add quality information to meta data (such as glitch and saturation rate)
slicedFrames = activateMasks(slicedFrames, slicedFrames.get(0).getMaskTypes())
slicedFrames = addQualityInformation(slicedFrames)
#
#
# converts the signal level to the smallest capacitance
# used cal file: capacitanceRatios
slicedFrames = convertSignal2StandardCap(slicedFrames, calTree=calTree)
#
#
# calculate the differential signal of each on-off pair for each chopper cycle
slicedFrames = specDiffChop(slicedFrames, scical = "sci", keepall = False, normalize=True)
#
#
# convert the Frames to a PacsCube
slicedCubes = specFrames2PacsCube(slicedFrames)        
#
#
# compute ra/dec meta keywords
slicedCubes = centerRaDecMetaData(slicedCubes)

#
#
# Update of the observation context
obs = updatePacsObservation(obs, 1.0, [slicedFrames, slicedCubes])


# Remove some variables (memory clean-up)
del slicedFrames, slicedCubes, level0_5