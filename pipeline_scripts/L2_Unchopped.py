# 
#  This file is part of Herschel Common Science System (HCSS).
#  Copyright 2001-2011 Herschel Science Ground Segment Consortium
# 
#  HCSS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as
#  published by the Free Software Foundation, either version 3 of
#  the License, or (at your option) any later version.
# 
#  HCSS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU Lesser General Public License for more details.
# 
#  You should have received a copy of the GNU Lesser General
#  Public License along with HCSS.
#  If not, see <http://www.gnu.org/licenses/>.
# 

"""
VERSION     
  $Id: L2_Unchopped.py,v 1.70 2016/06/14 16:27:22 jdejong Exp $      <do not touch. This field is changed by CVS>

PURPOSE
   PACS Spectrometer Pipeline of unchopped and wavelength switching AORs starting at level 1

   This is the third level of the pipeline scripts of the SPG - the Standard Product Generation, 
   a.k.a. the automatic pipeline that the HSC runs - and that which your HSA-gotten ObservationContext  
   were reduced with, if they were reduced in this same track. 

   The SPG scripts are similar to the interactive pipeline (ipipe) scripts that PACS provides in HIPE,  
   but there are extra tasks that the ipipe scripts include, and so users should consider re-reducing
   their data with the ipipe scripts.
   This SPG script is provided so you can see what your HSA-gotten Observation Context levels 
   were reduced with. We provide some comments explaining what the individual tasks do, but for detailed 
   comments see the ipipe scripts, and for a detailed explanation of the pipeline, see the PACS Data 
   Reduction Guide.

   The ipipe scripts can be found under the HIPE menu Pipelines->Spectrometer->. From there you go 
   to the pipeline suited for your observation, such as Chopped line scan and short range scan->lineScan. 

  
AUTHOR
   Juergen Schreiber <schreiber@mpia.de>

WARNING
   Do not edit this file! This is the reference copy for your current 
   installation of HIPE. We recommend you first copy it to a different  
   location before editing.


INPUTS
   - obs : ObservationContext
       - Products needed to run the pipeline are extracted from it
       - Must already be loaded in HIPE, and should contain the previously-reduced Levels
   - camera : camera to reduce (only one done at a time)
       - "red" or "blue"
   - calTree : Calibration Tree from the observation, or generated within your HIPE session 
   
HISTORY 
  2009-03-13 JS 1.0 initial version 
  2009-06-24 JS 1.1 updated
  2009-07-16 JS 1.2 introduce slicing   
  2013-04-04 KME improve comments        
"""

from herschel.pacs.signal.context import *
from herschel.pacs.cal import GetPacsCalDataTask
from herschel.pacs.spg.common import *
from herschel.pacs.spg.spec import *
from herschel.ia.numeric import *
from herschel.ia.pal import *
from herschel.pacs.spg.pipeline import *  
from herschel.pacs.spg.pipeline.ProductSinkHandling import *
from herschel.pacs.spg.pipeline.spg_spec_tools import *


def replMap(product, key='redLeak'):
     map = MapContext()
     map.refs[key] = ProductRef(product)
     return map

#*******************************************************************************
# Preparation
#*******************************************************************************
#
# SETUP 1: 
#    red or blue camera? This the user has to set before running the script, using the command e.g.
#       > camera = "blue" 
#    the try/except here will set the camera to "blue" if it has not already been defined
try:
    camera
except NameError:
    camera = 'blue'

# Always use the product sink for this script
sink.setUsed(True)

#
# Extract the (previously-reduced) level 1 out of the ObservationContext
level1 = PacsContext(obs.level1)


# SETUP 2:
# Set up the calibration tree. 
# First check whether calTree already exists, since it could have been filled by the SPG pipeline 
# If not, then take it from your current HIPE build, and then put it into the ObservationContext 
#  so that it is stored there for future reference
try:
    calTree
except NameError:
    calTree = getCalTree(obs=obs)
    obs.calibration = calTree


# Extract the level-1 frames and cubes for your camera   
slicedCubes = level1.cube.getCamera(camera).product
slicedFrames = level1.fitted.getCamera(camera).product

#
# ***********************************************************************************
#         Processing
# ***********************************************************************************   
#   
# copyCube=True makes slicedCubes a fully independent product
copyCube = True

#
# Flatfielding for line spectroscopy and short range scans (up to 5 micron) only. 
# (See the ipipe scripts and the PDRG for an explanation of the flatfielding tasks.)
#
# For SED and large range spectroscopy, note that flatfielding is done in the ipipe scripts.
# (For line spectroscopy, you should anyway redo the flatfielding so you can check the results)
#
lineSpec = isLineSpec(slicedCubes)
shortRange = isShortRange(obs)
maskNotFF = False

if lineSpec or shortRange:
    ffUpsample = getUpsample(obs)
    
    # 1. Flag outliers and rebin
    waveGrid = wavelengthGrid(slicedCubes, oversample=2, upsample=ffUpsample, calTree=calTree)
    slicedCubes = activateMasks(slicedCubes, String1d(["GLITCH","UNCLEANCHOP","NOISYPIXELS","RAWSATURATION","SATURATION","GRATMOVE", "BADPIXELS"]), exclusive = True, copy = copyCube)
    copyCube = False
    slicedCubes = specFlagOutliers(slicedCubes, waveGrid, nSigma=5, nIter=1)
    slicedCubes = activateMasks(slicedCubes, String1d(["GLITCH","UNCLEANCHOP","NOISYPIXELS","RAWSATURATION","SATURATION","GRATMOVE", "OUTLIERS", "BADPIXELS"]), exclusive = True)
    slicedRebinnedCubes = specWaveRebin(slicedCubes, waveGrid)
    slicedCubes = selectSlices(slicedCubes,refContext=slicedRebinnedCubes)
    
    width = 2.5
    if isRangeSpec(obs):
        width = 1.5

    # 2. mask the line
    slicedCubes = maskLines(slicedCubes,slicedRebinnedCubes, calTree = calTree, widthDetect=width, widthMask=width, threshold=10.0)

    # 3. do the flatfielding
    slicedCubes = specFlatFieldLine(slicedCubes, calTree = calTree, scaling=1, maxrange=[190.0,220.0], slopeInContinuum=1, maxScaling=2., maskType="OUTLIERS_FF", offset=0)
    del ffUpsample, width
elif isRangeSpec(obs):
    slicedFrames = specFlatFieldRange(slicedFrames,useSplinesModel=True, excludeLeaks=False, selectedRange=[190.0, 220.0], calTree = calTree, copy = copyCube, wlIntervalKnots={1:2.0, 2:3.0, 3:2.0})
    copyCube = False
    maskNotFF = True
    slicedCubes = specFrames2PacsCube(slicedFrames)
    slicedCubes = centerRaDecMetaData(slicedCubes)
    

# Building the wavelength grids for each slice
# Used cal file: wavelengthGrid
upsample = getUpsample(obs)
waveGrid=wavelengthGrid(slicedCubes, oversample=2, upsample = upsample, calTree = calTree)
#
#
# Active masks 
slicedCubes = activateMasks(slicedCubes, String1d(["GLITCH","UNCLEANCHOP","SATURATION","GRATMOVE", "BADFITPIX", "BADPIXELS"]), exclusive = True, copy=copyCube)
#
#
# Flag the remaining outliers (sigma-clipping in wavelength domain), with default parameters here
slicedCubes = specFlagOutliers(slicedCubes, waveGrid)
#
#
# Rebin all cubes on consistent wavelength grids
masksForRebinning = String1d(["OUTOFBAND", "GLITCH", "UNCLEANCHOP", "SATURATION", "GRATMOVE", "BADFITPIX", "OUTLIERS", "BADPIXELS"])
#if maskNotFF:
masksForRebinning.append("NOTFFED")
slicedCubes = activateMasks(slicedCubes, masksForRebinning, exclusive = True)
slicedRebinnedCubes = specWaveRebin(slicedCubes, waveGrid)

# Only continue if there is at least one slice leftover after red-leak filtering
if slicedRebinnedCubes.refs.size()>0:
    
    # Select only the slices in the PACS cube which are also in the rebinned cube
    slicedCubes = selectSlices(slicedCubes,refContext=slicedRebinnedCubes)
    
    # Select the off position cubes to preserve them for the drizzling
    slicedOffRebinnedCubes = None
    try:
        slicedOffRebinnedCubes = selectSlices(slicedRebinnedCubes, onOff=['off'])
    except:
        print "No off-source cubes available"
    
    #
    #
    # subtract the off-position(s) that is(are) closest in time to the on-position(s) BUT only if we have a 
    # line scan observation
    if obs.meta["cusMode"].value == "PacsLineSpec":
        slicedRebinnedCubes = specSubtractOffPosition(slicedRebinnedCubes)
    #
    #
    # Average the rebinned cubes per raster position
    # This is the final science-grade product for spatially undersampled rasters and single pointings
    slicedRebinnedCubes = specAverageCubes(slicedRebinnedCubes)
    
    slicedRebinnedCubes = centerRaDecMetaData(slicedRebinnedCubes)
    
    # convert the cubes to a table 
    # slicedTable = pacsSpecCubeToTable(slicedRebinnedCubes)
    
    # Compute equidistant wavelength grid for equidistant regridding
    equidistantWaveGrid = wavelengthGrid(slicedCubes, oversample=2, upsample = upsample, calTree = calTree, regularGrid = True, fracMinBinSize = 0.35)
    
    #
    # determine mapping algorithm and parameters
    driz, pixelSize, interpolatePixelSize, oversampleSpace, upsampleSpace, pixFrac, source, mapType = determineMappingAlgorithm(slicedRebinnedCubes,camera)
    
    # Mosaic, per wavelength range, all raster pointings into a single cube
    slicedDrizzledCubes = None
    slicedDrizzledEquidistantCubes = None
    slicedInterpolatedCubes = None
    slicedInterpolatedEquidistantCubes = None
    slicedProjectedEquidistantCubes = None
    if driz:
        oversampleWave = 2
        upsampleWave = upsample
        slicedDiffCubes = slicedCubes
        if slicedOffRebinnedCubes != None:
            slicedDiffCubes = specSubtractOffPosition(slicedCubes, slicedOffRebinnedCubes)
        else:
            print "No off-positions to subtract before drizzling starts"
        waveGridForDrizzle = wavelengthGrid(slicedDiffCubes, oversample=oversampleWave, upsample=upsampleWave, calTree = calTree)
        equidistantWaveGridForDrizzle = wavelengthGrid(slicedCubes, oversample=oversampleWave, upsample = upsampleWave, calTree = calTree, regularGrid = True, fracMinBinSize = 0.35)
        spaceGrid = spatialGrid(slicedDiffCubes, wavelengthGrid=waveGridForDrizzle, oversample=oversampleSpace, upsample=upsampleSpace, pixfrac=pixFrac, calTree=calTree)
        slicedDrizzledCubes = drizzle(slicedDiffCubes, wavelengthGrid=waveGridForDrizzle, spatialGrid=spaceGrid)[0]
        slicedDrizzledCubes = centerRaDecMetaData(slicedDrizzledCubes)
        sink.saveWhenMemoryShort(slicedDrizzledCubes)
        slicedDrizzledEquidistantCubes = specRegridWavelength(slicedDrizzledCubes, equidistantWaveGridForDrizzle)
        sink.saveWhenMemoryShort(slicedDrizzledEquidistantCubes)
        slicedProjectedCubes = specProject(slicedRebinnedCubes, cubeWithOutputGrid=slicedDrizzledCubes)
        del spaceGrid, waveGridForDrizzle, equidistantWaveGridForDrizzle, oversampleWave, upsampleWave
    else:
        slicedProjectedCubes = specProject(slicedRebinnedCubes,outputPixelsize=pixelSize)
        if mapType != "oversampled":
            slicedInterpolatedCubes = specInterpolate(slicedRebinnedCubes,outputPixelsize=interpolatePixelSize)
            slicedInterpolatedCubes = centerRaDecMetaData(slicedInterpolatedCubes)
            sink.saveWhenMemoryShort(slicedInterpolatedCubes)
        if (mapType=="nyquist" or mapType=="oversampled"):
            slicedProjectedEquidistantCubes = specRegridWavelength(slicedProjectedCubes, equidistantWaveGrid)
            sink.saveWhenMemoryShort(slicedProjectedEquidistantCubes)
        else:
            slicedInterpolatedEquidistantCubes = specRegridWavelength(slicedInterpolatedCubes, equidistantWaveGrid)
            sink.saveWhenMemoryShort(slicedInterpolatedEquidistantCubes)
    
    slicedProjectedCubes = centerRaDecMetaData(slicedProjectedCubes)
    sink.saveWhenMemoryShort(slicedProjectedCubes)
    
    # do a pointsource extraction for the pointed observations only
    spectra1d = None
    if source=='point':
        if isRangeSpec(obs):
            c1, c9, c129 = extractCentralSpectrum(slicedRebinnedCubes, smoothing='filter', width=50, preFilterWidth=15,  calTree=calTree)
        else:
            c1, c9, c129 = extractCentralSpectrum(slicedRebinnedCubes, smoothing='median', calTree=calTree)
        spectra1d = fillPacsCentralSpectra(slicedRebinnedCubes, ptSrcSpec = c1, ptSrc3x3Spec = c9)
        del c1, c9, c129
    
    # update the level 2 of the ObservationContext 
    obs = updatePacsObservation(obs, 2.0, [slicedCubes, slicedRebinnedCubes, slicedProjectedCubes, \
    slicedDrizzledCubes, slicedDrizzledEquidistantCubes,  slicedProjectedEquidistantCubes, \
    # slicedTable, slicedInterpolatedCubes, slicedInterpolatedEquidistantCubes, spectra1d])
    slicedInterpolatedCubes, slicedInterpolatedEquidistantCubes, spectra1d])

    level2 = obs.level2.copy()

    #We are only changing the level2 cubes in the red, spectral tables are out
    productNames=level2.refs.keys()
    productNamesRed=[ name for name in productNames if (name[::-1].find('R') == 0)]

    #The mapContext creates a subdirectory and has the advantage it creates a filename_extension.fits
    #mapContext class is used as a proxy to have various sliced products below
    for prodIndiv in productNamesRed:
        product = level2.refs[prodIndiv].product
        level2.refs[prodIndiv] = ProductRef(replMap(product))
        level2.refs[prodIndiv].product.refs['redLeak'].product.type = prodIndiv+'_redLeak'

    obs.level2 = level2
    
    del slicedOffRebinnedCubes, equidistantWaveGrid, driz, pixelSize, interpolatePixelSize, \
    # del slicedOffRebinnedCubes, slicedTable, equidistantWaveGrid, driz, pixelSize, interpolatePixelSize, \
    oversampleSpace, upsampleSpace, pixFrac, source, mapType, slicedProjectedCubes, \
    slicedInterpolatedCubes, slicedDrizzledCubes, slicedDrizzledEquidistantCubes, \
    slicedProjectedEquidistantCubes, slicedInterpolatedEquidistantCubes, spectra1d
else:
    LOGGER.warning("No slices left anymore after filtering red-leak and out-of-band slices.")

# Delete some variables (memory clean-up)
del copyCube, slicedCubes, slicedFrames, lineSpec, shortRange, maskNotFF, upsample,\
masksForRebinning, slicedRebinnedCubes, waveGrid

# restore the old sink state
restoreOldSinkState()
